# Стандарт кодування відділу розвитку АБС "Б-2" Альфа Банк (Україна) для Oracle на SQL і PL\SQL

При написанні стандарту кодування як основа використовувався стандарт кодування для Oracle на SQL і PL\SQL компанії CS Integra.

## Цілі та область дії

Цей стандарт кодування призначений для внутрішнього використання розробниками відділу розвитку АБС "Б-2" для підвищення читабельності початкового коду і полегшення його супроводу.

Стандарт поширюється на всі об'єкти бази даних, створені співробітниками відділу.

## Загальні правила оформлення коду

У найменуванні процедур, функцій, змінних, констант і т.д. необхідно використовувати [UpperCamelCase](https://uk.wikipedia.org/wiki/%D0%92%D0%B5%D1%80%D0%B1%D0%BB%D1%8E%D0%B6%D0%B8%D0%B9_%D1%80%D0%B5%D0%B3%D1%96%D1%81%D1%82%D1%80).
При цьому назви пакетів рекомендується починати з **pk(g|i|r|m)** в нижньому регістрі.

Після ключового слова END, закінчення пакета, процедури або функції, необхідно прописувати найменування пакету/процедури/функції.

У коді необхідно уникати використання [магічних чисел](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) замінюючи їх на константи. При цьому вкрай бажано щоб по найменуванню константи можна було дізнатися її призначення.

Наприклад, код:
``` sql
SELECT d.Id
  FROM Deal d
 WHERE d.DealTypeId = 356
   AND d.DealState in (0,1)
   AND d.ContragentId = lContragentId;
```

необхідно замінювати на
``` sql
SELECT d.Id
  FROM Deal d
 WHERE d.DealTypeId = pkc_Deal.ldtLoanOnTime
   AND d.DealState IN (pkc_Deal.DS_NotStarted,pkc_Deal.DS_Active)
   AND d.ContragentId = lContragentId;
```

Якщо в процесі роботи над заявкою змінюється об'єкт форматування якого не відповідає вимогам цього документа необхідно привести форматування змінюваного об'єкта до актуальних вимог щодо форматування. При цьому якщо змінюється тільки одна, або кілька функцій/процедур пакету, то коригується тільки їх форматування.

Наприклад:

``` sql
  FUNCTION uses_summa_ondealtranche(
    in_dealid     NUMBER,
    in_account    VARCHAR2,
    in_date       DATE,
    in_currencyid NUMBER DEFAULT NULL)
  RETURN NUMBER
    IS
    result NUMBER;
  BEGIN

    BEGIN
      SELECT  NVL(SUM (incsumma - decsumma),0)
        INTO result
        FROM (SELECT ddt.dealid, ddt.valuedate,
                   DECODE (ddt.otbs, 0, ddt.usesumma, 0) incsumma,
                   DECODE (ddt.otbs, 1, ddt.usesumma, 0) decsumma, ddt.otbs
              FROM deal td, dealdoctransaction ddt, aaccount A,dealcommercialtranche dct
             WHERE td.ID = ddt.dealid
               AND td.valuedate <= in_date
               AND ddt.valuedate <= in_date
               AND ddt.accountid = A.ID
               AND A.accountno = in_account
               AND A.currencyid = NVL(in_currencyid,dct.currencyid)
               AND dct.dealid = in_dealid
               AND td.ID=dct.dealid
               );
      EXCEPTION
      WHEN NO_DATA_FOUND THEN
         result:=0;
    END;

    RETURN result;

  END;
```

Переформатований код:

- В назві функції використано CamelCase
- Всі найменування змінних приведено до одного виду
- Якщо відомий тип поля з якого вибираються дані, то цей тип використовується для змінної
- Код і коментар вирівняні по блоках

``` sql
  FUNCTION Uses_Summa_OnDealTranche (
    in_DealId        NUMBER,
    in_Account       VARCHAR2,
    in_Date          DATE,
    in_CurrencyId    NUMBER DEFAULT NULL)
  RETURN NUMBER
  IS
    lResult   NUMBER;
  BEGIN
    IF in_Account IS NOT NULL THEN
      BEGIN
        SELECT NVL (SUM (IncSumma - DecSumma), 0)
          INTO lResult
          FROM (SELECT ddt.DealId,
                       ddt.ValueDate,
                       DECODE (ddt.OTBS, 0, ddt.UseSumma, 0) IncSumma,
                       DECODE (ddt.OTBS, 1, ddt.UseSumma, 0) DecSumma,
                       ddt.OTBS
                  FROM Deal td,
                       DealDocTransaction ddt,
                       Aaccount a,
                       DealCommercialTranche dct
                 WHERE td.ID = ddt.DealId
                   AND td.ValueDate <= in_Date
                   AND ddt.ValueDate <= in_Date
                   AND ddt.AccountId = a.ID
                   AND a.AccountNo = in_Account
                   AND a.CurrencyId = NVL (in_CurrencyId, dct.CurrencyId)
                   AND dct.DealId = in_DealId
                   AND td.Id = dct.DealId);
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          lResult := 0;
      END;
    ELSE
      lResult := 0;
    END IF;

    RETURN lResult;
  END Uses_Summa_OnDealTranche;
```

### Відступи, вирівнювання, межі рядка, переноси

Розмір одного відступу по горизонталі - 2 пробіли.

В настройках редактора завжди потрібно відключати опцію використання символів табуляції.

Максимальна довжина рядка - 80 символів (**до обговорення**). Якщо рядок коду виходить за кордон праворуч, бажано перенести його частину на наступний рядок і витримати відповідні відступи.

При перенесенні операторів необхідно робити відступи таким чином, щоб логічно зв'язкові групи, елементи перерахування розміщувалися на одній вертикалі відповідно до свого рівня вкладеності в конструкції.

### Розстановка відступів, дужок, операторів, коментарів

Арифметичні оператори, оператори порівняння рекомендується завжди відділяти пробілами по обидва боки. Оператор присвоєння виділяється обов'язково.

``` sql
a + b * c – 5.01 / 6

(b + a) * d
```

Після кожної коми при перерахуванні параметрів, елементів масиву і ін. необхідно ставити пробіл.

Крапка з комою, круглі і квадратні дужки не виділяються пробілами.

При запису довгих констант-рядків оператор конкатенації з'являється тільки в тому випадку, якщо рядок виходить за кордон рядка справа (80 символів від лівого краю). Бажано переносити оператор конкатенації на новий рядок, а не залишати на попередній. Такий код простіше читати і коментувати.

``` sql
dmbs_output.put_line (
     'Текст в скрипті який дуже важливий і дуже довгий, ну дуже довгий,'
  || 'Більше 80 символів і використовує конкатенцію щоб вміститься в 80'
  || 'Символів')
```

При створенні коментарів використовуються ті ж принципи форматування що і для блоку коду до якого вони належать.

*Приклад недотримання відступу для блоку коду в коментарях*

``` sql
    BEGIN
-- ищем код счета - так нельзя, коментарий должен иметь тот же отступ что и SELECT
      SELECT aa.Id
        INTO lId
        FROM Aaccount aa
       WHERE aa.AccountNo = pAccountNo
         AND aa.CurrencyId = pCurrencyId;
    EXCEPTION    
      WHEN NO_DATA_FOUND THEN
        lId := NULL;
    END;
```

*Приклад недотримання вимоги обмеження довжини рядка*

``` sql
    BEGIN   
      SELECT aa.BAccountId
        INTO lBAccountId
        FROM Aaccount aa
       WHERE aa.Id = 123456;
      IF lBAccountId = 2620 THEN
        lMessage := 'Same message for BAccount 2620'; -- требования заявки CR-123456 после пользовательского тестирования
      ELSE
        lMessage := 'Same message for another BAccount';
      END IF;
    EXCEPTION    
      WHEN NO_DATA_FOUND THEN
        lBAccountId := NULL;
    END;
```

Чи не засмічуйте модулі закоментованим старим кодом. Це погіршує читабельність коду. У банку використовується система контролю версій за допомогою якої, при необхідності, можна отримати попередню версію файлу.

## Найменування елементів коду

При найменуванні змінних, констант, або об'єктів бази даних повинен використовуватися Upper Camel Case.

Назву змінної бажано починати з символа "l" - lVariable

Назву параметрів процедури, чи функції бажано починати з символа "p" - pParameter. При чому, якщо функція, чи процедура пишеться для точки розширення, то дана рекомендація не має дотримуватись.
Назву констант бажано почитани з символа "c" - cConstanta.

***Потрібно узгодити як мають називатись***:

2. Константи різних типів, констант Б-2
3. явні курсор
4. типи Даних (ОКРЕМІ и Всередині пакетів)

При найменуванні змінних, констант, явних курсорів і типів даних усередині пакета, в уже існуючих пакетах, процедурах і функціях, необхідно дотримуватись того ж принципу яких був використаний спочатку.

Наприклад, якщо в процедурі найменування змінних починається з символів 'l_', то і новостворені змінні повинні починатися з цих же символів, або потрібно змінити назви всіх старих констант (рекомендовано)

## Найменування об'єктів

Для можливості простої ідентифікації об'єктів створених в банку ці об'єкти повинні містити слово ** Alfa **.

При цьому якщо створюється функція, або процедура всередині пакету, то слово **Alfa** повинно бути тільки в найменуванні пакета. Навіть якщо функція / процедура була створена перенесенням окремого об'єкта в пакет.

### Таблиці, ключі, інші поля

### Типи даних

### Обмеження, Constraints

### Огляди

### Процедури і функції

### Пакети

## Послідовності (Sequences)


## Структура SVN відділу розвитку АБС Б2

### Загальні вимоги до роботи з SVN

Розробка DDL і DML скриптів повинна вестися в файлах і зберігатись в SVN. Це істотно зменшує виникнення конфліктів при перестворенні тестових баз даних, встановленні заявок в продуктив, а також дозволяє вести аналіз зміни об'єктів різними розробниками і по різних заявках.

При виконанні commit'ов в SVN коментар необхідно починати з вказанням коду заявки CR, і коду BUG, ​​якщо зміни стосуються виправлення, (для підтягування в розділ Subversion Commits в заявці JIRA), а також короткий опис доопрацювання/зміни.

**Не допускаються коментарі які містять тільки номер заявки.**

**Перейменування і переміщення** вже існуючих об'єктів необхідно робити засобами Tourtoise SVN, а не засобами ОС (бажано попередньо перевірити на тестовому SVN).

У кожному створюваному SQL скрипт має бути присутня **"шапка"** типу:

``` sql
/********************************************************************************
Название:   ...
Назначение: .....
Версия:     $Rev$

История изменений:
Дата        Автор                 Описание
----------  --------------------  ---------------------------------------------

********************************************************************************/
```

Щоб "шапка" збереглася в об'єкті бази даних, а не тільки в SVN необхідно вказувати "шапку" після рядка з `create or replace`.

У властивостях SQL-файлів необхідно **додавати ключове слово "Rev"**, інакше макрос $Rev$ працювати не буде.

Оскільки ключові слова можна додавати тільки для файлів що знаходяться в репозитарії, то, щоб уникнути зайвого виконання Commit, потрібно відразу після створення файлу, **до commit'а в репозиторій**, вибрати в контекстному меню файлу пункт "TortoiseSVN" -> "Add ... "(це додасть створений файл в репозиторій), а потім вже зайти в властивості файлу і додати ключове слово" Rev "як описано в [SVN Quick Start User Guide](http://confluence.forum.kiev.ua. alfabank/display/systems/SVN+Quick+Start+User+Guide)

### Структура SVN

Структура каталогів SVN містить два каталогу:

- **Trunc** - основна гілка каталогу
- **Branch** - гілка для зміни існуючих об'єктів бази даних

### Гілка trunc

Гілка містить наступні каталоги

: Структура гілки **trunc**

| Каталог | Призначення |
| --------- | :-------------------------------------------------- |
| **CR** | Містить підкаталоги по номерах заявок типу CR. У підкаталогах розміщуються разові патчі, які не створюють об'єкти, а також скрипти для створення об'єктів вендора які увійдуть в наступні ХФ/релізи. |
| **OBJ** | Каталог об'єктів (процедури, функції, пакети, таблиці, уявлення і т.д.) |
| **Operations** | Дампи операцій |
| **PBM** | Скрипти розроблені в рамках PBM |
| **Releases** | Каталог містить підкаталоги номерів версій релізів/ХФ від вендора. Служить для патчів, які виправляють баги виявлені під час установки, або тестування релізу/ХФ. |
| **Reports** | Внутрішньобанківські звіти |
| **SD** | Містить скрипти виправлень інцедентів |
| **Tools** | Містить скрипти для завантаження дампів, створення простих завдань, і т.д. |



#### Загальні вимоги до DDL об'єктів (trunc/OBJ)

Файл містить DDL об'єкта Oracle має збігатися з ім'ям цього об'єкта і в тому ж регістрі.

Якщо об'єкт створюється не в схемі CREATOR, то в ім'я файлу додається відповідний префікс з точкою.

**Subversion розрізняє назви файлів в різному регістрі! Хоча в локальній копії під Windows файли з найменуваннями в різному регістрі не помітні, при виконанні commit файли *pkg_alfa_over.sql* і *PKG_ALFA_OVER.sql* вважаються різними!**

DDL для розроблених банком таблиць і індексів для промислової експлуатації необхідно створювати із зазначенням табличного простору *B2_ALFA_DAT*.

DDL таблиць і індексів для тимчасового використання необхідно створювати із зазначенням табличного простору *B2_TMP_DAT* (назви таблиць починаються зі слова ALFA_TMP * ...)

<!--
* Бажані також коментарі вхідних / вихідних параметрів в процедурах і функціях (принаймні тих, чия назва не очевидно відображає сенс).
* У таблиці, представлення - загальний коментар і коментарі для полів.
-->

#### "Нумерація" розробників
<a name="developer_code"> </a>

Для уникнення конфліктів при установці в продуктив в файлах звітів, операцій і простих завдань використовується "особиста цифра" розробника:

- 00 - Усенко А.;
- 01 - Новоставський Р.;
- 02 - Булавінов В.І.;
- 03 - Гурин А.;
- 07 - Гаюк С.;
- 08 - Наумяк Ю.;
- 09 - Лішнянський А.;
- 10 - Ємельянов І.;
- 11 - відділ інтеграційних рішень;
- 12 - відділ інтеграційних рішень;
- 14 - Гребінь Ю.
- 15 - співробітники управління операційного дня банку;
- 16 - сотрудник CS;
- 17 - Филимончук В.
- 18 - Котляревский О.
- 20 - Булавінов В.І.;

#### Звіти

Звіти зберігаються в файлах з зазначенням альтернативного ключа в імені файлу з префіксом 'R_'.

Альтернативний ключ формується у вигляді `3XXNNNN`, де

- '3' - фіксована частина ключа для звітів відділу розвитку АБС
- 'XX' - ["особиста цифра" розробника](#developer_code)
- 'NNNN' - номер заявки CR в рамках якої був створений звіт. Якщо в рамках заявки було створено кілька звітів, то до імені файлу додається символ підкреслення і порядковий номер звіту в заявці. При наступних доопрацювань в рамках інших заявок номер звіту міняти не потрібно. Якщо допрацьовується існуючий звіт, у якого альтернативний код не задовольняє вищеописаним вимогам - можлива зміна альтернативного коду (і імені файлу в SVN), так як при імпорті звіту в продуктив все одно буде потрібно видалити стару версію, якщо в неї немає внутрішнього коду (звіти, що не мають внутрішнього коду, Б2 оновлювати НЕ вміє).

В поле "Історія" звіту в Б2 - обов'язкове вказання ​​розробника і, бажано, номери заявок, за якими він допрацьовувався.

Якщо звіт при виклику використовує шаблон з мережевого каталогу, то в ньому потрібно використовувати константу банку **AlfaReportPath** - для продуктива там буде зберігатися значення каталогу **O:\ODBShablon**, для тестового середовища - **O:\ODBShablonTest**. В SVN шаблони для таких звітів зберігаються в каталозі [/Reports/ODBShablon](http://flink.forum.kiev.ua.alfabank/svn/common/projects/B2/trunk/Reports/ODBShablon).

#### Операції

**Нумерація операцій** здійснюється наступним способом:

- Для ручних операцій береться мінімальне вільне значення поля ID з таблиці "operation";
- Номери операцій, які будуть використовуватися в Батчі нумеруються згідно масці **8XXNN** де XX - ["особистий код" розробника](# developer_code), NN - порядковий номер;
- Номера технологічних операцій формуються відповідно по масці **9XXNN** де XX - "особистий код" розробника (той же що і для звітів), NN - порядковий номер.

**Дампи операцій** зберігаються в окремому каталозі з ім'ям рівним номеру операції. Актуальні скрипти для імпорту / експорту операцій зберігаються в одиничному екземплярі в каталозі [SVN/Tools/ExchOper](http://flink.forum.kiev.ua.alfabank/svn/common/projects/B2/trunk/Tools/ExchOper).

**потрібно обговорити чи це потрібно**

Поруч з дампом операції, при необхідності, зберігаємо скрипт наповнення *ALPHA_OPERCHECK*, який повинен бути кумулятивним (тобто спочатку очищати всі перевірки по операції а потім наповнювати заново). Найменування скрипта має збігатися з кодом операції. (Про використання таблиці ALPHA_OPERCHECK можна почитати в [Confluence](http: //confluence.forum.kiev.ua.alfabank/display/systems/Alpha_OpCheck+Procedure))

Для пошуку вільних номерів операцій можна використовувати скрипт:

``` sql
SELECT *
  FROM (SELECT LEVEL + 99000 r1
              FROM DUAL
        CONNECT BY LEVEL <1000) A
 WHERE NOT EXISTS
          (SELECT 1
             FROM operation o
            WHERE A.r1 = o.ID) {code} або {code: sql} WITH tmp AS (SELECT LEVEL AS ID
                FROM dual
             CONNECT BY LEVEL <= 99999);

SELECT *
  FROM tmp
 WHERE tmp.ID BETWEEN 99000 AND 99999
   AND tmp.ID NOT IN (SELECT o.ID FROM Operation o)
```

#### Прості задачі

**Прості задачі** Б2 нумеруються згідно масці *5XXNNN* де XX - "особистий код" розробника, NNN - порядковий номер (той же що і для звітів). Допускається групувати пов'язані задачі на розсуд розробника.

При розробці простих завдань рекомендується створити просту задачу на тестовій схемі, і з допомогою скрипта [MakeTaskInstall](http: //flink.forum.kiev.ua.alfabank/svn/common/projects/B2/trunk/Tools/TaskExport) створити інсталяційний патч, який буде містити всі необхідні команди для створення простої задачі, її полів, системних фільтрів, операцій і зв'язків. Також, опціонально, патч може містити видачу прав на задачі групі CREATOR.

Відомі обмеження **MakeTaskInstall.sql**:

- Не експортуються настройки колонок системних фільтрів (тому що зберігаються в CLOB), а також не створюються ніякі об'єкти Oracle (скрипт генерує тільки DML-код).
- Якщо дві створювані прості задачі мають перехресні зв'язку, доведеться виділяти створення зв'язків в окремі скрипти.
- Якщо ви змінюєте існуючу задачу, то результуючий патч потрібно коригувати вручну. **Не рекомендується видаляти задачі тому що на неї можуть бути видані права користувачам. **

**Іноді виявляється відставання sequence *GenEntityLink_Usr* від *EntityLink.Id* - ймовірно "підступи CS", тому що задачі з EntityLink.Id і GenEntityLink_Usr явно "не наші". Для виправлення такої проблеми потрібно одноразово "докрутити" sequence (потрібний для цього код закоментований в скрипті)**

<!-- {info:title=.
{info}
 -->
<!-- ## Предполагаемая структура каталогов
{flowchart}
rankdir=LR
trunk
Obj
Reports
Operations
CR
trunk -> CR
trunk -> Operations
trunk -> Reports
trunk -> Obj
trunk -> Tools
trunk -> Releases
Reports -> ODBShablon
Obj -> Tables
Obj -> Views
Obj -> Triggers
Obj -> Functions
Obj -> Procedures
Obj -> Packages
Obj -> Sequences
Obj -> Links
Obj -> Type
CR -> "CR-1"
CR -> "CR-2"
CR -> "CR-..."
Operations -> "101.dmp"
Operations -> "102.dmp"
Operations -> "..."

{flowchart} -->

### Гілка branch
<a name="branch"> </a>

У разі, якщо в рамках заявки потрібна зміна існуючого об'єкта, то для підтримки стабільності гілки **trunc** необхідно робити відгалуження файлу який містить код створення об'єкта в гілку SVN **branch**.

Для цього перед початком зміни об'єкту розробник робить відгалуження файлу з гілки **trunc** за допомогою команди [Branch/Tag](https://tortoisesvn.net/docs/release/TortoiseSVN_ru/tsvn-dug-branchtag.html). URL відгалуження повинен мати наступний вигляд - branch/\<номер заявки\>, де "номер заявки"" це номер заявки по якій робиться зміна об'єкта.

Саме цей файл прописується в документації і віддається в ІТ-тестування. У цьому ж файлі фіксуються виправлення помилок за заявкою.

Після закінчення користувацького тестування розробник робить злиття змін з файлу відгалуження в файл гілки **trunc** (робить **merge**).

Необхідно мати на увазі, що команда SVN **merge** дуже часто завершується з конфліктами, які вимагають прийняття ручного рішення. У більшості випадків простіше порівняти два файли і за різницею зробити ручний "merge".

> Якщо за час, який заявка по якій робився branch тестувалася були зміни цього об'єкта в trunc, то бажано перед виконанням тестування внести зміни, які робилися в гілці **trunc** в файл в гілці **branch**.

Після закінчення виконання **merge** нова ревізія прописується в документації і про необхідність проведення smoke тестування повідомляється тестувальник заявки.

Після успішного виконання smoke тестування тестувальник повинен відписатися в заявці про результати smoke тестування із зазначенням які ревізії були перетестовані.


## Використання типових шаблонів в коді SQL і PL\SQL

### Використання SQL в коді

Поради Steven Feuerstein:

> Перестаньте писати багато SQL! Кожен SQL вираз це хард код існуючої структури даних.
> Не повторюйте той же SQL вираз.
> Тримайте SQL повністю окремо від коду програми.
> Натомість створюйте і використовуйте API функції і процедури в яких заховані SQL вирази.

Великим плюсом винесення роботи з SQL в окремі "API" процедури/функції є те, що збільшується кількість однакових DML конструкцій, що в результаті зменшує кількість «hard parse», а значить зменшить завантаження CPU і пам'яті (SGA).

Необхідно мати на увазі, що hard parse буде виконуватися навіть якщо DML візуально схожі і це може суттєво впливати на продуктивність:

``` sql
SELECT aa.Id INTO lId FROM Aaccount aa WHERE aa.AccountNo = lAccountNo AND aa.CurrencyId = lCurrencyId;
select a.id into lId from aaccount a where a.AccountNo = lAccountNo and a.currencyid = lCurrencyId;
```

Це не означає що всі SQL вирази повинні бути винесені в окремі процедури і функції.

Але якщо необхідно вставляти/обновляти/видаляти дані в таблиці, то чому це не можна винести в окрему процедуру? Особливо якщо такий DML буде використовуватись кілька раз в одній, або різних процедура.

Якщо необхідно отримувати дані про контрагента, то чому не використовувати універсальну функцію?

### Пошук та робота з окремими записами в таблиці

При вибірці одиничної записи за допомогою SELECT INTO не забувайте про можливість виникнення помилок **NO_DATA_FOUND** і **TOO_MANY_ROWS**.

Якщо необхідно в коді PL\SQL просто перевірити наявність значення в таблиці, використовуйте такий шаблон:

``` sql
select count (1)
  into lRes
  from aaccount
 where AccountNo like lID || '%'
   and RowNum = 1; -- Обмеження за кількістю одержуваних даних
```

Якщо потрібно витягти деякий ідентифікатор сутності з таблиці, а при його відсутності створити нову сутність, то є два варіанти:

1. якщо всі дані для вставки вже готові, просто виконайте INSERT і нехай, якщо задане значення вже існує, виникне виключення (primary key violated і т.п.);
2. якщо підготовка даних для вставки займає багато часу, краще зробити попередній запит UPDATE ... RETURNING, або SELECT INTO з урахуванням можливого **NO_DATA_FOUND**.


## Думки

- Add labels to the END statements of all your packages, procedures, functions, etc. It is a small thing that greatly aids in readability.
- Rely on a single, generic error manager utility to raise, handle and log errors.
Individual developers should never waste their time calling DBMS_UTILITY.FORMAT_ERROR_BACKTRACE (though you should definitely know what that is!) Or writing inserts into log tables. You end with total chaos and inconsistent information for both users and support. The best way to avoid this is to rely on a single utility.
- Stop writing so much SQL! Every SQL statement is a hard-coding of the current data structures. Do not repeat the same logical SQL statement. Keep SQL out of application-level code entirely. Instead, generate / build and rely on APIs (tablelevel, transaction-level) that hide SQL statements behind procedures and functions.
- Write tiny, little chunks of code (J). Use top-down design, combined with reusable code and local subprograms (procedures and functions declared within another procedure or function), to make sure that your executable sections have no more than 50 lines of code in them. Define your subprograms at the package level if they need to be used by more than one program in that package or outside of that package.
- I also recommend that you avoid any OUT or IN OUT parameters for a function - it should return information only through the RETURN clause. If the function needs to return multiple values, group those values ​​together as a record type and return a record based on that type. If such a transformation seems unnatural then maybe you should be writing a procedure.

- Не допускається використання декількох значень, що повертаються в функціях. Для таких випадків необхідно використовувати процедури
- У функціях точка повернення значення має бути одна

## Література

[Стандарт кодирования для Oracle на SQL и PL\SQL. Компания CS](http://confluence.forum.kiev.ua.alfabank/download/attachments/28118385/%D0%A1%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82+%D0%BA%D0%BE%D0%B4%D0%B0+SQL.doc)

[PL/SQL Naming Conventions and Coding Standards - Steven Feuerstein 2009](https://community.oracle.com/docs/DOC-1007838)

[Coding Standards for SQL and PL/SQL - William Robertson](https://oracle-base.com/articles/misc/naming-conventions)

[ORACLE-BASE / Tim Hall / Oracle Naming Conventions](https://oracle-base.com/articles/misc/naming-conventions)

[Trivadis PL/SQL and SQL Coding Guidelines Version 2.0](http://www.trivadis.com/sites/default/files/downloads/PLSQL_and_SQL_Coding_Guidelines_2_0_HiRes.pdf)

[Ask Tom on Naming Conventions](https://asktom.oracle.com/pls/apex/f?p=100:11:0::::P11_QUESTION_ID:6729304326802)

[PL/SQL and SQL naming conventions](http://www.oraclethoughts.com/sql/plsql-and-sql-naming-conventions/)

[Oracle SQL and PL/SQL Coding Standards – Cat Herding for Dummies](https://mikesmithers.wordpress.com/2011/10/22/oracle-sql-and-plsql-coding-standards-%E2%80%93-cat-herding-for-dummies/)

[Slideshare Presentation on PL/SQL Coding Conventions](http://www.slideshare.net/little.frank.yu/plsql-coding-conventions-6726050)